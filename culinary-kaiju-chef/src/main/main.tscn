[gd_scene load_steps=5 format=3 uid="uid://cy8tfx3i5lxe1"]

[ext_resource type="Script" path="res://src/main/Main.gd" id="1"]
[ext_resource type="Script" path="res://src/ui/screens/game_hud.gd" id="2"]

[sub_resource type="Environment" id="Environment_1"]
background_mode = 1
background_color = Color(0.1, 0.1, 0.15, 1)

[sub_resource type="GDScript" id="GDScript_1"]
script/source = "# CulinaryKaijuMain.gd - Simplified main scene controller
extends Node2D

# Core game objects - using ENHANCED_COMPLETE logic
@onready var monster_chef: CharacterBody2D
@onready var ingredient_collector: Area2D
@onready var game_hud = $GameHUD

# Game state
var monster_level: int = 1

# Enhanced enemy data - load from resources
var enemy_data_list: Array[EnemyData] = []
var boss_data_list: Array[EnemyData] = []
var last_boss_time: float = 0.0
var boss_interval: float = 300.0  # 5 minutes between bosses
var appetite: int = 0
var appetite_required: int = 100
var ingredients_chopped: int = 0
var game_time: float = 0.0
var chef_health: int = 100
var chef_max_health: int = 100

# Enhanced stats
var monster_chef_speed: float = 200.0
var cleaver_damage: int = 25
var cleavers_per_attack: int = 2
var attack_speed_multiplier: float = 1.0

# Multi-weapon system - Enhanced
var active_weapons: Array[String] = [\"cleaver\"]
var weapon_timers: Dictionary = {\"cleaver\": 0.0}
var weapon_levels: Dictionary = {\"cleaver\": 1}  # Track weapon levels
var weapon_data_cache: Dictionary = {}  # Cache loaded weapon data

# Game objects arrays
var rebellious_ingredients: Array[Area2D] = []
var flying_cleavers: Array[Area2D] = []
var whisk_tornadoes: Array[Area2D] = []
var enemy_projectiles: Array[Area2D] = []
var spice_essences: Array[Area2D] = []

# Timers
var ingredient_spawn_timer: float = 0.0

# Upgrade database
var enhanced_upgrades = [
    {\"name\": \"🔪 Cleaver Mastery\", \"desc\": \"Throw +2 more cleavers!\\nMore blades = more chaos!\", \"type\": \"cleavers\", \"value\": 2},
    {\"name\": \"⚔️ Razor Edge\", \"desc\": \"Cleavers deal +20 damage!\\nSharp enough to cut reality!\", \"type\": \"damage\", \"value\": 20},
    {\"name\": \"⚡ Lightning Hands\", \"desc\": \"Attack 30% faster!\\nMaster chef speed!\", \"type\": \"speed\", \"value\": 0.7},
    {\"name\": \"💪 Kaiju Vigor\", \"desc\": \"Move 40% faster!\\nSwift domination!\", \"type\": \"movement\", \"value\": 40},
    {\"name\": \"🐉 Giant Growth\", \"desc\": \"Grow 25% larger!\\nImposing presence!\", \"type\": \"size\", \"value\": 1.25},
    {\"name\": \"🌟 Spice Magnet\", \"desc\": \"Attract spice 50% farther!\\nMagnetic aura!\", \"type\": \"magnet\", \"value\": 1.5},
    {\"name\": \"🌪️ Whisk Tornado\", \"desc\": \"UNLOCK: Spinning whisk weapon!\\nTornado of destruction!\", \"type\": \"unlock_weapon\", \"value\": \"whisk\"},
    {\"name\": \"💚 Chef's Resilience\", \"desc\": \"Increase max health by 25!\\nTougher warrior!\", \"type\": \"health\", \"value\": 25}
]

# Enhanced upgrade system - use proper UI
var upgrade_screen_instance: CanvasLayer

func _ready():
    print(\"🍳🐉 === CULINARY KAIJU CHEF MAIN SCENE === 🐉🍳\")
    
    # Set up effects manager reference
    EffectsManager.set_main_scene(self)
    
    # Load enemy data from resources
    load_enemy_data()
    
    # Apply permanent upgrades at start
    apply_permanent_bonuses()
    
    # Load upgrade screen
    load_upgrade_screen()
    
    setup_game()
    create_monster_chef()
    connect_systems()
    spawn_initial_battle()
    update_all_ui()

func load_enemy_data():
    # Load all enemy types from data files
    var enemy_files = [
        \"res://features/enemies/enemy_data/onion_grunt.tres\",
        \"res://features/enemies/enemy_data/speed_demon.tres\", 
        \"res://features/enemies/enemy_data/tank_brute.tres\",
        \"res://features/enemies/enemy_data/ranged_carrot.tres\",
        \"res://features/enemies/enemy_data/bomber_pepper.tres\",
        \"res://features/enemies/enemy_data/healer_mushroom.tres\"
    ]
    
    # Load boss data separately
    var boss_files = [
        \"res://features/enemies/enemy_data/boss_giant_onion.tres\",
        \"res://features/enemies/enemy_data/boss_tomato_overlord.tres\"
    ]
    
    for file_path in enemy_files:
        if ResourceLoader.exists(file_path):
            var enemy_data = load(file_path) as EnemyData
            if enemy_data:
                enemy_data_list.append(enemy_data)
                print(\"Loaded enemy: \", enemy_data.name)
    
    for file_path in boss_files:
        if ResourceLoader.exists(file_path):
            var boss_data = load(file_path) as EnemyData
            if boss_data:
                boss_data_list.append(boss_data)
                print(\"Loaded boss: \", boss_data.name)
    
    print(\"Total enemies loaded: \", enemy_data_list.size())
    print(\"Total bosses loaded: \", boss_data_list.size())
    
    # Load weapon data
    load_weapon_data()

func load_weapon_data():
    var weapon_files = [
        \"res://features/weapons/weapon_data/throwing_knife.tres\",
        \"res://features/weapons/weapon_data/fan_knife.tres\",
        \"res://features/weapons/weapon_data/piercer.tres\",
        \"res://features/weapons/weapon_data/cleaver_storm_evolved.tres\"
    ]
    
    for file_path in weapon_files:
        if ResourceLoader.exists(file_path):
            var weapon_data = load(file_path) as WeaponData
            if weapon_data:
                weapon_data_cache[weapon_data.name.to_lower().replace(\" \", \"_\")] = weapon_data
                print(\"Loaded weapon: \", weapon_data.name)

func apply_permanent_bonuses():
    var bonuses = PlayerData.get_permanent_bonuses()
    
    # Apply bonuses to base stats
    chef_max_health += bonuses.health_bonus
    chef_health = chef_max_health
    cleaver_damage = int(cleaver_damage * (1.0 + bonuses.damage_bonus))
    monster_chef_speed *= (1.0 + bonuses.speed_bonus)
    
    print(\"Applied permanent bonuses: +%d health, +%.1f%% damage, +%.1f%% speed\" % [
        bonuses.health_bonus, 
        bonuses.damage_bonus * 100,
        bonuses.speed_bonus * 100
    ])

func setup_game():
    # Hide all templates initially if they exist
    for template in [\"OnionTemplate\", \"TomatoTemplate\", \"CleaverTemplate\", \"SpiceTemplate\"]:
        var node = get_node_or_null(template)
        if node:
            node.hide()

func create_monster_chef():
    # Create player dynamically
    monster_chef = CharacterBody2D.new()
    monster_chef.name = \"MonsterChef\"
    monster_chef.collision_layer = 2  # player layer
    monster_chef.collision_mask = 1 | 4 | 32  # world, enemies, collectables
    
    # Visual representation
    var sprite = ColorRect.new()
    sprite.size = Vector2(80, 80)
    sprite.position = Vector2(-40, -40)
    sprite.color = Color(0.2, 0.8, 0.3)  # Green monster chef
    monster_chef.add_child(sprite)
    
    # Add a simple face
    var eye1 = ColorRect.new()
    eye1.size = Vector2(12, 12)
    eye1.position = Vector2(-25, -15)
    eye1.color = Color.WHITE
    sprite.add_child(eye1)
    
    var eye2 = ColorRect.new()
    eye2.size = Vector2(12, 12)
    eye2.position = Vector2(13, -15)
    eye2.color = Color.WHITE
    sprite.add_child(eye2)
    
    var mouth = ColorRect.new()
    mouth.size = Vector2(30, 8)
    mouth.position = Vector2(-15, 10)
    mouth.color = Color.BLACK
    sprite.add_child(mouth)
    
    # Collision
    var collision = CollisionShape2D.new()
    var shape = RectangleShape2D.new()
    shape.size = Vector2(70, 70)
    collision.shape = shape
    monster_chef.add_child(collision)
    
    # Ingredient collector
    ingredient_collector = Area2D.new()
    ingredient_collector.name = \"IngredientCollector\"
    ingredient_collector.collision_layer = 0
    ingredient_collector.collision_mask = 32  # collectables
    
    var collector_collision = CollisionShape2D.new()
    var collector_shape = CircleShape2D.new()
    collector_shape.radius = 50
    collector_collision.shape = collector_shape
    collector_collision.name = \"CollectorShape\"
    ingredient_collector.add_child(collector_collision)
    
    monster_chef.add_child(ingredient_collector)
    add_child(monster_chef)
    
    # Center camera on player
    var camera = Camera2D.new()
    camera.enabled = true
    monster_chef.add_child(camera)

func connect_systems():
    if ingredient_collector:
        ingredient_collector.area_entered.connect(_on_spice_collected)

func _process(delta):
    if is_upgrading:
        return
    
    game_time += delta
    handle_chef_movement(delta)
    handle_enemy_spawning(delta)
    handle_combat(delta)
    update_battlefield(delta)
    cleanup_battlefield()
    update_timer_and_stats()

func handle_chef_movement(_delta: float):
    var input_dir = Input.get_vector(\"move_left\", \"move_right\", \"move_up\", \"move_down\")
    var actual_speed = monster_chef_speed * (1.0 + monster_level * 0.08)
    monster_chef.velocity = input_dir * actual_speed
    monster_chef.move_and_slide()
    
    if input_dir.x != 0:
        monster_chef.scale.x = abs(monster_chef.scale.x) * (1 if input_dir.x > 0 else -1)

func handle_enemy_spawning(delta: float):
    ingredient_spawn_timer += delta
    var spawn_interval = max(0.6, 2.0 - (monster_level * 0.12))
    
    if ingredient_spawn_timer > spawn_interval:
        ingredient_spawn_timer = 0.0
        spawn_dynamic_enemy()

func spawn_dynamic_enemy():
    # Check if it's time for a boss fight (every 5 minutes)
    if game_time - last_boss_time >= boss_interval and not boss_data_list.is_empty():
        spawn_boss()
        return
    
    # Select enemy type based on level progression
    var available_enemies = get_enemies_for_level(monster_level)
    if available_enemies.is_empty():
        return
    
    var selected_enemy = available_enemies[randi() % available_enemies.size()]
    spawn_enemy_from_data(selected_enemy)

func spawn_boss():
    if boss_data_list.is_empty():
        return
    
    # Clear screen of regular enemies for dramatic effect
    clear_screen_for_boss()
    
    # Select boss based on time/level
    var boss_index = min(int(game_time / boss_interval), boss_data_list.size() - 1)
    var boss_data = boss_data_list[boss_index]
    
    # Spawn boss with enhanced stats
    var boss = create_boss_template(boss_data)
    
    last_boss_time = game_time
    boss_interval = min(boss_interval * 1.2, 600.0)  # Increase interval, max 10 min
    
    # Dramatic effects
    EffectsManager.screen_flash(Color.RED, 0.6, 1.0)
    AudioManager.play_sfx(\"level_up\", 5.0, 0.5)  # Deep bass sound
    
    print(\"🔥 BOSS SPAWNED: %s\" % boss_data.name)

func create_boss_template(boss_data: EnemyData) -> Area2D:
    var boss = create_enemy_template(\"boss\", boss_data.sprite_modulate)
    
    # Boss-specific scaling
    boss.scale = boss_data.sprite_scale
    
    # Enhanced stats based on current level
    var health = boss_data.health + (monster_level * 50)
    var speed = boss_data.speed
    var xp = boss_data.xp_reward + (monster_level * 20)
    
    setup_enemy_metadata(boss, \"boss\", health, speed, xp)
    
    # Boss special abilities
    boss.set_meta(\"is_boss\", true)
    boss.set_meta(\"summon_cooldown\", 10.0)
    boss.set_meta(\"summon_timer\", 0.0)
    boss.set_meta(\"rage_threshold\", health * 0.5)  # Rage at 50% health
    boss.set_meta(\"is_enraged\", false)
    
    setup_boss_behavior(boss, boss_data)
    
    boss.area_entered.connect(func(area): hit_ingredient(boss, area))
    rebellious_ingredients.append(boss)
    
    return boss

func setup_boss_behavior(boss: Area2D, boss_data: EnemyData):
    match boss_data.name:
        \"Giant Onion King\":
            boss.set_meta(\"special_attack\", \"toxic_cloud\")
            boss.set_meta(\"special_cooldown\", 8.0)
            boss.set_meta(\"special_timer\", 0.0)
        \"Tomato Overlord\":
            boss.set_meta(\"special_attack\", \"meteor_storm\")
            boss.set_meta(\"special_cooldown\", 12.0)
            boss.set_meta(\"special_timer\", 0.0)

func clear_screen_for_boss():
    # Remove some regular enemies for dramatic effect
    var enemies_to_remove = min(rebellious_ingredients.size() / 2, 5)
    for i in enemies_to_remove:
        if i < rebellious_ingredients.size():
            var enemy = rebellious_ingredients[i]
            if not enemy.get_meta(\"is_boss\", false):
                rebellious_ingredients.erase(enemy)
                enemy.call_deferred(\"queue_free\")

func get_enemies_for_level(level: int) -> Array[EnemyData]:
    var available: Array[EnemyData] = []
    
    for enemy in enemy_data_list:
        var spawn_chance = get_enemy_spawn_chance(enemy.name, level)
        
        if randf() < spawn_chance:
            available.append(enemy)
    
    return available

func get_enemy_spawn_chance(enemy_name: String, level: int) -> float:
    # Data-driven approach - could be moved to enemy data resources
    var spawn_rules = {
        "Onion Grunt": {"min_level": 1, "base_chance": 1.0},
        "Speed Demon": {"min_level": 2, "base_chance": 0.8},
        "Tank Brute": {"min_level": 3, "base_chance": 0.6},
        "Ranged Carrot": {"min_level": 4, "base_chance": 0.5},
        "Bomber Pepper": {"min_level": 5, "base_chance": 0.4},
        "Healer Mushroom": {"min_level": 6, "base_chance": 0.3}
    }
    
    var rule = spawn_rules.get(enemy_name, {"min_level": 99, "base_chance": 0.0})
    
    if level >= rule.min_level:
        return rule.base_chance
    else:
        return 0.0

func spawn_enemy_from_data(enemy_data: EnemyData):
    var enemy = create_enemy_template(enemy_data.name.to_lower().replace(\" \", \"_\"), enemy_data.sprite_modulate)
    
    # Apply data from resource
    var health = enemy_data.health + (monster_level * 5)
    var speed = enemy_data.speed + (monster_level * 2)
    var xp = enemy_data.xp_reward + monster_level
    
    setup_enemy_metadata(enemy, enemy_data.name.to_lower().replace(\" \", \"_\"), health, speed, xp)
    
    # Special behaviors based on enemy type
    setup_special_behavior(enemy, enemy_data)
    
    enemy.area_entered.connect(func(area): hit_ingredient(enemy, area))
    rebellious_ingredients.append(enemy)

func setup_special_behavior(enemy: Area2D, enemy_data: EnemyData):
    match enemy_data.name:
        \"Ranged Carrot\":
            enemy.set_meta(\"attack_range\", 250.0)
            enemy.set_meta(\"attack_damage\", 10 + monster_level)
            enemy.set_meta(\"attack_timer\", 0.0)
            enemy.set_meta(\"attack_cooldown\", 3.0)
        \"Bomber Pepper\":
            enemy.set_meta(\"explodes_on_death\", true)
            enemy.set_meta(\"explosion_damage\", 20 + monster_level * 2)
            enemy.set_meta(\"explosion_radius\", 80.0)
        \"Healer Mushroom\":
            enemy.set_meta(\"heal_range\", 100.0)
            enemy.set_meta(\"heal_amount\", 5)
            enemy.set_meta(\"heal_cooldown\", 5.0)
            enemy.set_meta(\"heal_timer\", 0.0)
        \"Speed Demon\":
            enemy.set_meta(\"dash_cooldown\", 2.0)
            enemy.set_meta(\"dash_timer\", 0.0)
            enemy.set_meta(\"dash_speed\", enemy_data.speed * 2)
        \"Tank Brute\":
            enemy.set_meta(\"charge_cooldown\", 4.0)
            enemy.set_meta(\"charge_timer\", 0.0)

func spawn_onion():
    var onion = create_enemy_template(\"onion\", Color(0.8, 0.6, 0.9))  # Purple-ish onion
    
    var health = 35 + (monster_level * 5)
    var speed = 55 + (monster_level * 3)
    var xp = 12 + monster_level
    
    setup_enemy_metadata(onion, \"onion\", health, speed, xp)
    onion.area_entered.connect(func(area): hit_ingredient(onion, area))
    rebellious_ingredients.append(onion)

func spawn_tomato():
    var tomato = create_enemy_template(\"tomato\", Color.RED)
    
    var health = 50 + (monster_level * 6)
    var speed = 40 + (monster_level * 2)
    var xp = 18 + (monster_level * 2)
    
    setup_enemy_metadata(tomato, \"tomato\", health, speed, xp)
    tomato.set_meta(\"attack_range\", 220.0)
    tomato.set_meta(\"attack_damage\", 12 + monster_level)
    tomato.set_meta(\"attack_timer\", 0.0)
    tomato.set_meta(\"attack_cooldown\", 2.8)
    
    tomato.area_entered.connect(func(area): hit_ingredient(tomato, area))
    rebellious_ingredients.append(tomato)

func create_enemy_template(enemy_type: String, color: Color) -> Area2D:
    var enemy = Area2D.new()
    enemy.collision_layer = 4  # enemies layer
    enemy.collision_mask = 8   # player_weapons layer
    
    # Visual
    var sprite_container = Node2D.new()
    sprite_container.name = enemy_type.capitalize() + \"Sprite\"
    
    var sprite = ColorRect.new()
    sprite.size = Vector2(40, 40)
    sprite.position = Vector2(-20, -20)
    sprite.color = color
    sprite_container.add_child(sprite)
    
    # Add eyes for character
    var eye1 = ColorRect.new()
    eye1.size = Vector2(6, 6)
    eye1.position = Vector2(-12, -8)
    eye1.color = Color.BLACK
    sprite.add_child(eye1)
    
    var eye2 = ColorRect.new()
    eye2.size = Vector2(6, 6)
    eye2.position = Vector2(6, -8)
    eye2.color = Color.BLACK
    sprite.add_child(eye2)
    
    enemy.add_child(sprite_container)
    
    # Collision
    var collision = CollisionShape2D.new()
    var shape = RectangleShape2D.new()
    shape.size = Vector2(35, 35)
    collision.shape = shape
    enemy.add_child(collision)
    
    add_child(enemy)
    position_enemy_around_chef(enemy)
    
    return enemy

func setup_enemy_metadata(enemy: Area2D, type: String, health: int, speed: int, xp: int):
    enemy.set_meta(\"enemy_type\", type)
    enemy.set_meta(\"health\", health)
    enemy.set_meta(\"max_health\", health)
    enemy.set_meta(\"speed\", speed)
    enemy.set_meta(\"xp\", xp)

func position_enemy_around_chef(enemy: Area2D):
    var angle = randf() * TAU
    var distance = 650 + randf() * 200
    enemy.global_position = monster_chef.global_position + Vector2.RIGHT.rotated(angle) * distance

func handle_combat(delta: float):
    # Cleaver system
    weapon_timers[\"cleaver\"] += delta
    var cleaver_interval = (1.4 / attack_speed_multiplier) - (monster_level * 0.06)
    if weapon_timers[\"cleaver\"] > max(0.25, cleaver_interval):
        weapon_timers[\"cleaver\"] = 0.0
        if \"cleaver\" in active_weapons:
            throw_cleavers()
    
    # Whisk tornado system
    if \"whisk\" in active_weapons:
        weapon_timers[\"whisk\"] += delta
        if weapon_timers[\"whisk\"] > 3.5:
            weapon_timers[\"whisk\"] = 0.0
            create_whisk_tornado()

func throw_cleavers():
    var targets = find_nearest_enemies(cleavers_per_attack)
    
    for i in range(cleavers_per_attack):
        var cleaver = create_cleaver()
        
        var direction: Vector2
        if i < targets.size():
            var target = targets[i]
            var predicted_pos = predict_target_position(target)
            direction = (predicted_pos - monster_chef.global_position).normalized()
        else:
            var spread = (TAU / cleavers_per_attack) * i + randf_range(-0.25, 0.25)
            direction = Vector2.RIGHT.rotated(spread)
        
        launch_cleaver(cleaver, direction)

func create_cleaver():
    var cleaver = Area2D.new()
    cleaver.collision_layer = 8  # player_weapons
    cleaver.collision_mask = 4   # enemies
    
    # Visual - simple cleaver representation
    var sprite = Node2D.new()
    var blade = ColorRect.new()
    blade.size = Vector2(20, 8)
    blade.position = Vector2(-10, -4)
    blade.color = Color.SILVER
    sprite.add_child(blade)
    
    var handle = ColorRect.new()
    handle.size = Vector2(4, 15)
    handle.position = Vector2(-2, 4)
    handle.color = Color(0.4, 0.2, 0.1)
    sprite.add_child(handle)
    
    cleaver.add_child(sprite)
    
    # Collision
    var collision = CollisionShape2D.new()
    var shape = RectangleShape2D.new()
    shape.size = Vector2(18, 6)
    collision.shape = shape
    cleaver.add_child(collision)
    
    add_child(cleaver)
    
    cleaver.set_meta(\"damage\", cleaver_damage)
    cleaver.set_meta(\"speed\", 320.0 + (monster_level * 10))
    cleaver.set_meta(\"lifetime\", 4.5)
    
    return cleaver

func launch_cleaver(cleaver: Area2D, direction: Vector2):
    cleaver.global_position = monster_chef.global_position
    cleaver.set_meta(\"direction\", direction)
    cleaver.rotation = direction.angle()
    flying_cleavers.append(cleaver)

func predict_target_position(target: Area2D) -> Vector2:
    var speed = target.get_meta(\"speed\", 50.0)
    var direction_to_chef = (monster_chef.global_position - target.global_position).normalized()
    var predicted_movement = direction_to_chef * speed * 0.4
    return target.global_position + predicted_movement

func create_whisk_tornado():
    var whisk = Area2D.new()
    whisk.collision_layer = 8
    whisk.collision_mask = 4
    
    # Visual
    var sprite = Node2D.new()
    var handle = ColorRect.new()
    handle.size = Vector2(4, 30)
    handle.position = Vector2(-2, -15)
    handle.color = Color(0.4, 0.2, 0.1)
    sprite.add_child(handle)
    
    var tornado_effect = ColorRect.new()
    tornado_effect.size = Vector2(120, 120)
    tornado_effect.position = Vector2(-60, -60)
    tornado_effect.color = Color(0.8, 1, 1, 0.4)
    sprite.add_child(tornado_effect)
    
    whisk.add_child(sprite)
    
    # Collision
    var collision = CollisionShape2D.new()
    var shape = CircleShape2D.new()
    shape.radius = 60
    collision.shape = shape
    whisk.add_child(collision)
    
    add_child(whisk)
    whisk.global_position = monster_chef.global_position
    
    var direction = find_tornado_direction()
    whisk.set_meta(\"direction\", direction)
    whisk.set_meta(\"damage\", cleaver_damage)
    whisk.set_meta(\"speed\", 120.0)
    whisk.set_meta(\"lifetime\", 5.0)
    whisk.set_meta(\"spin_speed\", 15.0)
    whisk.set_meta(\"affected_enemies\", [])
    
    whisk.area_entered.connect(func(area): _on_tornado_hits_enemy(whisk, area))
    whisk_tornadoes.append(whisk)
    
    print(\"🌪️ WHISK TORNADO UNLEASHED!\")

func find_tornado_direction() -> Vector2:
    if rebellious_ingredients.is_empty():
        return Vector2.RIGHT
    
    var center = Vector2.ZERO
    var count = 0
    
    for enemy in rebellious_ingredients:
        if is_instance_valid(enemy):
            center += enemy.global_position
            count += 1
    
    if count > 0:
        center /= count
        return (center - monster_chef.global_position).normalized()
    
    return Vector2.RIGHT

func _on_tornado_hits_enemy(tornado: Area2D, enemy: Area2D):
    if enemy in rebellious_ingredients:
        var affected = tornado.get_meta(\"affected_enemies\", [])
        if enemy not in affected:
            affected.append(enemy)
            tornado.set_meta(\"affected_enemies\", affected)
            damage_ingredient(enemy, tornado.get_meta(\"damage\", 25))

func update_battlefield(delta: float):
    update_ingredients(delta)
    update_cleavers(delta)
    update_whisk_tornadoes(delta)
    update_enemy_projectiles(delta)
    update_spice_essences(delta)

func update_ingredients(delta: float):
    for ingredient in rebellious_ingredients:
        if not is_instance_valid(ingredient):
            continue
        
        var enemy_type = ingredient.get_meta(\"enemy_type\", \"onion\")
        
        match enemy_type:
            \"onion\":
                update_onion(ingredient, delta)
            \"tomato\":
                update_tomato(ingredient, delta)

func update_onion(onion: Area2D, delta: float):
    var speed = onion.get_meta(\"speed\", 55.0)
    var direction = (monster_chef.global_position - onion.global_position).normalized()
    
    var wobble = Vector2(sin(game_time * 3) * 10, cos(game_time * 2.5) * 8)
    onion.global_position += (direction * speed + wobble) * delta
    
    var sprite = onion.get_node_or_null(\"OnionSprite\")
    if sprite:
        sprite.rotation += (speed / 15.0) * delta
    
    if onion.global_position.distance_to(monster_chef.global_position) < 65:
        take_chef_damage(8 + monster_level)
        rebellious_ingredients.erase(onion)
        onion.call_deferred(\"queue_free\")

func update_tomato(tomato: Area2D, delta: float):
    var distance = tomato.global_position.distance_to(monster_chef.global_position)
    var attack_range = tomato.get_meta(\"attack_range\", 220.0)
    var speed = tomato.get_meta(\"speed\", 40.0)
    
    if distance > attack_range:
        var direction = (monster_chef.global_position - tomato.global_position).normalized()
        tomato.global_position += direction * speed * delta
        
        var sprite = tomato.get_node_or_null(\"TomatoSprite\")
        if sprite:
            sprite.position.y = sin(game_time * 4) * 4
    else:
        var attack_timer = tomato.get_meta(\"attack_timer\", 0.0) + delta
        tomato.set_meta(\"attack_timer\", attack_timer)
        
        var cooldown = tomato.get_meta(\"attack_cooldown\", 2.8)
        if attack_timer >= cooldown:
            tomato.set_meta(\"attack_timer\", 0.0)
            tomato_attack(tomato)

func tomato_attack(tomato: Area2D):
    var acid = Area2D.new()
    acid.collision_layer = 16
    acid.collision_mask = 2
    
    var acid_sprite = ColorRect.new()
    acid_sprite.size = Vector2(10, 10)
    acid_sprite.position = Vector2(-5, -5)
    acid_sprite.color = Color.RED
    acid.add_child(acid_sprite)
    
    var collision = CollisionShape2D.new()
    var shape = CircleShape2D.new()
    shape.radius = 5
    collision.shape = shape
    acid.add_child(collision)
    
    add_child(acid)
    acid.global_position = tomato.global_position
    
    var chef_velocity = monster_chef.velocity
    var predicted_chef_pos = monster_chef.global_position + chef_velocity * 0.5
    var direction = (predicted_chef_pos - tomato.global_position).normalized()
    
    acid.set_meta(\"direction\", direction)
    acid.set_meta(\"speed\", 180.0)
    acid.set_meta(\"damage\", tomato.get_meta(\"attack_damage\", 12))
    acid.set_meta(\"lifetime\", 4.0)
    
    enemy_projectiles.append(acid)

func update_cleavers(delta: float):
    for cleaver in flying_cleavers:
        if not is_instance_valid(cleaver):
            continue
        
        var direction = cleaver.get_meta(\"direction\", Vector2.RIGHT)
        var speed = cleaver.get_meta(\"speed\", 320.0)
        var lifetime = cleaver.get_meta(\"lifetime\", 4.5) - delta
        
        cleaver.global_position += direction * speed * delta
        cleaver.rotation += 10.0 * delta
        cleaver.set_meta(\"lifetime\", lifetime)
        
        if lifetime <= 0 or cleaver.global_position.distance_to(monster_chef.global_position) > 1000:
            flying_cleavers.erase(cleaver)
            cleaver.call_deferred(\"queue_free\")

func update_whisk_tornadoes(delta: float):
    for whisk in whisk_tornadoes:
        if not is_instance_valid(whisk):
            continue
        
        var direction = whisk.get_meta(\"direction\", Vector2.RIGHT)
        var speed = whisk.get_meta(\"speed\", 120.0)
        var lifetime = whisk.get_meta(\"lifetime\", 5.0) - delta
        var spin_speed = whisk.get_meta(\"spin_speed\", 15.0)
        
        whisk.global_position += direction * speed * delta
        whisk.set_meta(\"lifetime\", lifetime)
        
        var sprite = whisk.get_children()[0]
        if sprite:
            sprite.rotation += spin_speed * delta
        
        if lifetime <= 0:
            whisk_tornadoes.erase(whisk)
            create_tornado_explosion(whisk.global_position)
            whisk.call_deferred(\"queue_free\")

func create_tornado_explosion(explosion_position: Vector2):
    var explosion = ColorRect.new()
    explosion.size = Vector2(200, 200)
    explosion.position = Vector2(-100, -100)
    explosion.color = Color(1, 1, 0, 0.8)
    add_child(explosion)
    explosion.global_position = explosion_position
    
    var tween = create_tween()
    tween.set_parallel(true)
    tween.tween_property(explosion, \"scale\", Vector2(2, 2), 0.6).set_ease(Tween.EASE_OUT)
    tween.tween_property(explosion, \"modulate\", Color(1, 1, 0, 0), 0.6)
    tween.finished.connect(func(): explosion.queue_free())

func update_enemy_projectiles(delta: float):
    for projectile in enemy_projectiles:
        if not is_instance_valid(projectile):
            continue
        
        var direction = projectile.get_meta(\"direction\", Vector2.RIGHT)
        var speed = projectile.get_meta(\"speed\", 180.0)
        var lifetime = projectile.get_meta(\"lifetime\", 4.0) - delta
        
        projectile.global_position += direction * speed * delta
        projectile.set_meta(\"lifetime\", lifetime)
        
        if projectile.global_position.distance_to(monster_chef.global_position) < 45:
            var damage = projectile.get_meta(\"damage\", 12)
            take_chef_damage(damage)
            enemy_projectiles.erase(projectile)
            projectile.call_deferred(\"queue_free\")
            continue
        
        if lifetime <= 0:
            enemy_projectiles.erase(projectile)
            projectile.call_deferred(\"queue_free\")

func update_spice_essences(delta: float):
    for spice in spice_essences:
        if not is_instance_valid(spice):
            continue
        
        var direction = (monster_chef.global_position - spice.global_position).normalized()
        var attraction = (120.0 + monster_level * 15) * delta
        spice.global_position += direction * attraction

func take_chef_damage(damage: int):
    chef_health = max(0, chef_health - damage)
    
    monster_chef.modulate = Color.RED
    create_tween().tween_property(monster_chef, \"modulate\", Color.WHITE, 0.25)
    
    update_health_ui()
    
    if chef_health <= 0:
        game_over()

func game_over():
    print(\"💀 GAME OVER!\")
    print(\"📊 Final Stats:\")
    print(\"   - Level: %d\" % monster_level)
    print(\"   - Ingredients: %d\" % ingredients_chopped)
    print(\"   - Time: %.1f seconds\" % game_time)
    
    # Update persistent stats
    var stats_update = {
        \"total_damage_dealt\": ingredients_chopped * cleaver_damage,  # Approximate
        \"total_time_played\": game_time,
        \"highest_level_reached\": monster_level
    }
    PlayerData.update_lifetime_stats(stats_update)
    
    # Award coins based on performance
    var bonuses = PlayerData.get_permanent_bonuses()
    var base_coins = ingredients_chopped + (monster_level * 10)
    var final_coins = int(base_coins * bonuses.coin_multiplier)
    PlayerData.add_coins(final_coins)
    
    print(\"💰 Coins earned: %d\" % final_coins)
    
    # Save the run data
    PlayerData.record_run(ingredients_chopped * 100, monster_level, game_time, ingredients_chopped)
    
    get_tree().reload_current_scene()

func hit_ingredient(ingredient: Area2D, weapon: Area2D):
    if weapon in flying_cleavers:
        var damage = weapon.get_meta(\"damage\", 25)
        damage_ingredient(ingredient, damage)
        flying_cleavers.erase(weapon)
        # Use call_deferred for safe removal during physics processing
        weapon.call_deferred(\"queue_free\")
        
        # Play hit sound
        AudioManager.play_sfx(\"enemy_hit\", -12.0, 1.0)

func damage_ingredient(ingredient: Area2D, damage: int):
    var current_health = ingredient.get_meta(\"health\", 35) - damage
    ingredient.set_meta(\"health\", current_health)
    
    var enemy_type = ingredient.get_meta(\"enemy_type\", \"onion\")
    var sprite_name = enemy_type.capitalize() + \"Sprite\"
    var sprite = ingredient.get_node_or_null(sprite_name)
    
    # Show damage number
    EffectsManager.damage_effect(ingredient.global_position, damage, damage > 30)
    
    if sprite:
        sprite.modulate = Color.RED
        create_tween().tween_property(sprite, \"modulate\", Color.WHITE, 0.15)
    
    if current_health <= 0:
        chop_ingredient(ingredient)

func chop_ingredient(ingredient: Area2D):
    var enemy_type = ingredient.get_meta(\"enemy_type\", \"onion\")
    var xp_reward = ingredient.get_meta(\"xp\", 12)
    
    if enemy_type == \"tomato\":
        xp_reward = int(xp_reward * 1.6)  # Tomatoes give more XP
    
    # Play death sound
    AudioManager.play_sfx(\"enemy_death\", -10.0, 1.0)
    
    # Show death explosion
    EffectsManager.death_effect(ingredient.global_position, enemy_type)
    
    # Use call_deferred to avoid physics state conflicts
    spawn_spice.call_deferred(ingredient.global_position, xp_reward, enemy_type)
    
    ingredients_chopped += 1
    appetite += xp_reward
    
    if appetite >= appetite_required:
        level_up()
    
    rebellious_ingredients.erase(ingredient)
    # Use call_deferred for safe removal during physics processing
    ingredient.call_deferred(\"queue_free\")
    update_all_ui()

func spawn_spice(spice_position: Vector2, value: int, ingredient_type: String):
    var spice = Area2D.new()
    spice.collision_layer = 32  # collectables
    spice.collision_mask = 0
    
    var color = Color.YELLOW
    match ingredient_type:
        \"tomato\":
            color = Color.GOLD
        \"onion\":
            color = Color.ORANGE
    
    var core = ColorRect.new()
    core.name = \"SpiceCore\"
    core.size = Vector2(15, 15)
    core.position = Vector2(-7.5, -7.5)
    core.color = color
    spice.add_child(core)
    
    var collision = CollisionShape2D.new()
    var shape = CircleShape2D.new()
    shape.radius = 10
    collision.shape = shape
    spice.add_child(collision)
    
    add_child(spice)
    spice.global_position = spice_position
    spice.set_meta(\"xp\", value)
    
    spice_essences.append(spice)

func _on_spice_collected(area: Area2D):
    if area in spice_essences:
        var xp_value = area.get_meta(\"xp\", 12)
        appetite += xp_value
        
        # Play pickup sound
        AudioManager.play_sfx(\"pickup\", -8.0, 1.0)
        
        if appetite >= appetite_required:
            level_up()
        
        spice_essences.erase(area)
        area.call_deferred(\"queue_free\")
        update_all_ui()

func level_up():
    monster_level += 1
    appetite = 0
    appetite_required = int(appetite_required * 1.45)
    
    chef_health = min(chef_max_health, chef_health + 15)
    
    # Play level up sound
    AudioManager.play_sfx(\"level_up\", -5.0, 1.0)
    
    show_upgrade_choices()
    update_all_ui()

func show_upgrade_choices():
    print(\"🎉 LEVEL UP! Level %d reached!\" % monster_level)
    print(\"Choose your upgrade (press 1, 2, or 3):\")
    
    var available = get_level_appropriate_upgrades()
    available.shuffle()
    
    current_upgrade_choices = [available[0], available[1], available[2]]
    
    for i in range(3):
        var upgrade = current_upgrade_choices[i]
        print(\"%d. %s - %s\" % [i+1, upgrade.name, upgrade.desc])
    
    is_upgrading = true

func get_level_appropriate_upgrades() -> Array[Dictionary]:
    var available: Array[Dictionary] = []
    
    for upgrade in enhanced_upgrades:
        if upgrade.type in [\"cleavers\", \"damage\", \"speed\", \"movement\", \"size\", \"magnet\", \"health\"]:
            available.append(upgrade)
        elif upgrade.type == \"unlock_weapon\":
            var weapon = upgrade.value
            if weapon == \"whisk\" and monster_level >= 3 and \"whisk\" not in active_weapons:
                available.append(upgrade)
    
    return available

func apply_upgrade(upgrade: Dictionary):
    match upgrade.type:
        \"cleavers\":
            cleavers_per_attack += upgrade.value
            # Check for weapon evolution
            check_weapon_evolution(\"cleaver\")
        \"damage\":
            cleaver_damage += upgrade.value
        \"speed\":
            attack_speed_multiplier /= upgrade.value
        \"movement\":
            monster_chef_speed += upgrade.value
        \"size\":
            monster_chef.scale *= upgrade.value
        \"magnet\":
            var collector = ingredient_collector.get_node(\"CollectorShape\").shape as CircleShape2D
            if collector:
                collector.radius *= upgrade.value
        \"health\":
            chef_max_health += upgrade.value
            chef_health += upgrade.value
        \"unlock_weapon\":
            var weapon = upgrade.value
            active_weapons.append(weapon)
            weapon_timers[weapon] = 0.0
            weapon_levels[weapon] = 1
    
    print(\"✨ Upgrade applied: %s\" % upgrade.name)

func check_weapon_evolution(weapon_key: String):
    if not weapon_levels.has(weapon_key):
        return
    
    var current_level = weapon_levels[weapon_key]
    
    # Check if weapon can evolve (reached max level)
    var weapon_data = get_weapon_data_for_key(weapon_key)
    if weapon_data and current_level >= weapon_data.max_level and weapon_data.evolution_result:
        evolve_weapon(weapon_key, weapon_data)

func get_weapon_data_for_key(weapon_key: String) -> WeaponData:
    match weapon_key:
        \"cleaver\":
            return weapon_data_cache.get(\"throwing_knife\", null)
        \"whisk\":
            return weapon_data_cache.get(\"fan_knife\", null)
        _:
            return weapon_data_cache.get(weapon_key, null)

func evolve_weapon(weapon_key: String, base_weapon: WeaponData):
    if not base_weapon.evolution_result:
        return
    
    # Remove old weapon
    var index = active_weapons.find(weapon_key)
    if index >= 0:
        active_weapons.remove_at(index)
    
    # Add evolved weapon
    var evolved_key = base_weapon.evolution_result.name.to_lower().replace(\" \", \"_\")
    active_weapons.append(evolved_key)
    weapon_timers[evolved_key] = 0.0
    weapon_levels[evolved_key] = 1
    
    # Visual and audio feedback
    EffectsManager.screen_flash(Color.GOLD, 0.5, 0.5)
    AudioManager.play_sfx(\"level_up\", 0.0, 1.2)
    
    print(\"🎆 WEAPON EVOLVED: %s -> %s\" % [base_weapon.name, base_weapon.evolution_result.name])

func update_all_ui():
    # Update HUD with current stats
    if game_hud:
        game_hud.update_stats(chef_health, chef_max_health, appetite, appetite_required, monster_level, ingredients_chopped)

func update_health_ui():
    # Update health in HUD
    if game_hud:
        game_hud.update_stats(chef_health, chef_max_health, appetite, appetite_required, monster_level, ingredients_chopped)

func update_timer_and_stats():
    # Console output for stats
    pass

func find_nearest_enemies(count: int) -> Array[Area2D]:
    var tomatoes: Array[Area2D] = []
    var onions: Array[Area2D] = []
    
    for ingredient in rebellious_ingredients:
        if is_instance_valid(ingredient):
            var enemy_type = ingredient.get_meta(\"enemy_type\", \"onion\")
            if enemy_type == \"tomato\":
                tomatoes.append(ingredient)
            else:
                onions.append(ingredient)
    
    tomatoes.sort_custom(func(a, b): return a.global_position.distance_to(monster_chef.global_position) < b.global_position.distance_to(monster_chef.global_position))
    onions.sort_custom(func(a, b): return a.global_position.distance_to(monster_chef.global_position) < b.global_position.distance_to(monster_chef.global_position))
    
    var targets: Array[Area2D] = []
    targets.append_array(tomatoes)
    targets.append_array(onions)
    
    return targets.slice(0, count)

func spawn_initial_battle():
    for i in range(3):
        spawn_onion()

func cleanup_battlefield():
    rebellious_ingredients = rebellious_ingredients.filter(func(obj): return is_instance_valid(obj))
    flying_cleavers = flying_cleavers.filter(func(obj): return is_instance_valid(obj))
    whisk_tornadoes = whisk_tornadoes.filter(func(obj): return is_instance_valid(obj))
    enemy_projectiles = enemy_projectiles.filter(func(obj): return is_instance_valid(obj))
    spice_essences = spice_essences.filter(func(obj): return is_instance_valid(obj))

func _input(event):
    if event.is_action_pressed(\"ui_accept\"):
        for i in range(6):
            if randf() > 0.4:
                spawn_onion()
            else:
                spawn_tomato()
        print(\"🚨 ENEMY WAVE! Mixed ingredients incoming!\")
    
    if event.is_action_pressed(\"ui_select\"):
        level_up()
        print(\"💪 Testing upgrade system!\")
    
    if is_upgrading:
        if event.is_action_pressed(\"ui_cancel\") or Input.is_key_pressed(KEY_1):
            apply_upgrade(current_upgrade_choices[0])
            is_upgrading = false
        elif Input.is_key_pressed(KEY_2):
            apply_upgrade(current_upgrade_choices[1])
            is_upgrading = false
        elif Input.is_key_pressed(KEY_3):
            apply_upgrade(current_upgrade_choices[2])
            is_upgrading = false
"

[node name="Main" type="Node2D"]
script = SubResource("GDScript_1")

[node name="WorldEnvironment" type="WorldEnvironment" parent="."]
environment = SubResource("Environment_1")

[node name="GameHUD" type="CanvasLayer" parent="."]
script = ExtResource("2")