好的，聽著。你們給我的那個所謂的「終極施工指令集」根本不是一份產品文件，那是一堆給 AI 的指令稿，亂七八糟。真正的產品文件（PRD）是寫給人看的，是我們的「憲法」，要用來統一思想，確保我們不做蠢事。

廢話少說。這是我為 `culinary-kaiju-chef` 這個專案重寫的 PRD。這份文件才是我們的唯一真理。所有人都必須嚴格遵守，尤其是 AI。

---

### **產品需求文件 (PRD): Culinary Kaiju Chef**

**版本:** 1.0
**作者:** Linus Torvalds
**狀態:** **最終草案 (DRAFT)** - 在我們完成第一階段並證明其可行性之前，別想著加任何新東西。

#### **1. 核心判斷 (Core Judgement)**

* **✅ 值得做**
    * **原因：** 市場上已經驗證了「倖存者 like」玩法的可行性。我們不需要重新發明輪子，只需要做得更有品味、性能更好。我們的策略是「**器官移植，而非從零創造**」—— 整合兩個現有的、功能明確的開源專案，然後用我們的架構思想重塑它。這將極大地縮短開發週期，讓我們能專注於真正重要的事情：一個穩定、流暢、可擴展的核心玩法循環。

#### **2. 核心哲學 (Core Philosophy)**

這不是什麼可選的建議，這是**鐵律 (The Law)**。

1.  **實用主義壓倒一切 (Pragmatism Above All):** 我們只解決真實存在的問題。不要為那些「可能」發生的邊界情況設計複雜的系統。如果一個功能不能直接提升核心玩法的樂趣或性能，它就是垃圾。
2.  **數據驅動，拒絕硬編碼 (Data-Driven, No Hardcoding):** 遊戲的所有配置——武器傷害、敵人血量、生成波次——都必須是獨立的 `.tres` 資源文件。程式碼只負責邏輯，數據負責內容。這是為了讓非程式設計師也能調整遊戲平衡，也是為了讓未來的擴展變得簡單。任何在程式碼中寫死的數值都是技術債，都必須被消滅。
3.  **性能是唯一的衡量標準 (Performance is the Only Metric):** 在移動平台上，性能就是生命線。我們必須從第一天起就為性能而設計。這意味著：
    * **手動位置更新：** 對於大量的敵人移動，放棄 Godot 的物理引擎。手動計算和更新 `global_position` 是唯一可接受的方案。
    * **物件池 (Object Pooling):** 敵人、子彈、特效等所有會被頻繁創建和銷毀的物件，都必須使用物件池。
    * **簡單碰撞：** 僅使用 `Area2D` 進行碰撞檢測。不要用 `CharacterBody2D` 或 `RigidBody2D` 來處理簡單的敵人。
4.  **消除特殊情況 (Eliminate Special Cases):** 「好品味」的程式碼會讓特殊情況消失。如果你的程式碼裡有大量的 `if-else` 來處理各種邊界條件，那說明你的設計從根上就錯了。重構它，找到一個更通用的模型，讓所有情況都走同一套邏輯。

#### **3. 產品需求 (Functional Requirements)**

我們分階段進行。每個階段都有明確的產出和驗收標準。

##### **階段 0: 奠基與器官移植 (Foundation & Integration)**

* **目標:** 建立一個可運行的、包含所有基礎功能但結構混亂的「怪物原型」。我們要把兩個捐贈者的「器官」（一個是框架，一個是玩法）粗暴地塞進我們的新身體裡。
* **產出物:**
    1.  **專案結構:** 一個名為 `culinary-kaiju-chef` 的 Godot 專案，包含 `src/`, `features/`, `assets/` 等所有預定義的資料夾結構。Git 已初始化，`.gitignore` 已配置。
    2.  **框架移植:**
        * `maaack/godot-game-template` 的核心框架（選單系統、場景加載器、設定檔管理器）被遷移到 `src/` 目錄下，並調整路徑使其在新結構中可用。
        * 例如：`addons/.../menus/` -> `src/ui/screens/`
    3.  **玩法移植:**
        * `sh-cho/godot-survivor-tutorial` 的核心玩法（玩家、敵人、武器、主場景）被作為一個獨立模組，完整遷移到 `features/survivor_core/` 目錄下。
        * `sh-cho` 的 `GameEvents` 單例被遷移到 `src/autoload/`。
    4.  **神經連接:**
        * 修改 `src/ui/screens/main_menu/main_menu.gd`，使其「開始遊戲」按鈕能夠透過 `SceneLoader` 正確加載 `features/survivor_core/main.tscn` 場景。
* **驗收標準 (Definition of Done):**
    * 專案可以無錯誤地運行。
    * 顯示主選單。
    * 點擊「開始遊戲」按鈕後，可以進入倖存者玩法的遊戲場景。
    * 玩家可以移動、敵人會生成、武器可以攻擊。
    * **程式碼品質在此階段不作要求。** 允許存在大量路徑錯誤修復和臨時的程式碼。

##### **階段 1: 核心玩法循環重構 (The Core Loop Refactoring)**

* **目標:** 將階段 0 的「怪物原型」重構成為一個結構清晰、數據驅動、性能可靠的遊戲核心。這是決定專案成敗的關鍵階段。
* **產出物:**
    1.  **數據化的武器系統:**
        * 創建 `src/core/data/WeaponData.gd` 作為所有武器的數據定義。
        * 在 `features/survivor_core/weapons/` 下，為每個武器（例如 `throwing_knife`）創建對應的 `.tres` 資源文件。
        * 重構 `player.gd` 和相關的武器腳本，使其所有屬性（傷害、速度、冷卻時間、發射數量）都從 `.tres` 文件中讀取。
    2.  **高性能的敵人系統:**
        * 重構 `features/survivor_core/enemies/base_enemy.gd`。
        * 確保敵人的根節點是 `Area2D`。
        * 移動邏輯必須透過手動修改 `global_position` 來實現。
        * 實現一個簡單的、非物理的敵人分離算法（例如 `_get_separation_vector()`），以防止敵人重疊。
    3.  **清晰的架構:**
        * 將 `features/survivor_core/` 內的程式碼，按照我們最終的架構藍圖進行拆分和重組。例如，將玩家輸入、玩家狀態、武器管理器等邏輯分離到不同的元件或節點中。
* **驗收標準 (Definition of Done):**
    * 核心玩法循環（移動、生成敵人、攻擊、升級）流暢可玩。
    * 遊戲內所有關鍵數值（武器、敵人）均已數據化，可以通過修改 `.tres` 文件來調整平衡。
    * 在同螢幕顯示 100 個以上敵人時，遊戲幀率保持穩定。
    * 程式碼遵循「**不超過 3 層縮進**」的原則，函數短小且功能單一。

##### **階段 2 & 3: 內容填充與商業化 (Content & Commercialization)**

* **目標:** 在穩定的核心玩法之上，填充遊戲內容，並加入商業化模組，準備發行。
* **產出物:**
    1.  **主題內容:**
        * 用「烹飪怪獸」主題的美術資源，替換所有來自模板的 placeholder。
        * 設計至少 3 種不同行為模式的敵人（例如：近戰的洋蔥、遠程的番茄）。
        * 設計至少 3 種可升級的武器。
    2.  **元成長 (Meta-Progression):**
        * 設計並實現一個局外成長系統，允許玩家使用在遊戲中獲得的「調味料」來永久性地提升基礎屬性。
    3.  **廣告整合:**
        * 使用 `awesome-godot` 列表推薦的 AdMob 插件，並將其整合到專案中。
        * 創建一個「遊戲結束」畫面 (`game_over_screen.tscn`)。
        * 在該畫面上實現一個「觀看廣告復活」按鈕，該按鈕必須透過 `EventBus` 發出 `player_revived_by_ad` 全局事件來觸發復活邏輯，而不是直接調用玩家節點。
* **驗收標準 (Definition of Done):**
    * 遊戲內容完整，具備可玩性。
    * 廣告激勵視頻可以正常播放，並在播放成功後觸發復活事件。
    * 遊戲可以在目標移動平台（iOS/Android）上成功打包並運行。

---

這就是我們的計畫。別再拿那份亂七八糟的 AI 指令集來煩我了。從現在開始，這份 PRD 就是唯一的開發依據。現在，從階段 0 的第一步開始執行。不要廢話，**Show me the code.**